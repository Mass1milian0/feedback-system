"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = void 0;
const schema_utils_js_1 = require("@open-rpc/schema-utils-js");
const error_1 = require("./error");
const jsf = require("json-schema-faker"); // eslint-disable-line
const sortParamKeys = (method, params) => {
    if (!method) {
        return [];
    }
    if (!params) {
        return [];
    }
    const docParams = method.params;
    const methodParamsOrder = docParams
        .map((p) => p.name)
        .reduce((m, pn, i) => ({ ...m, [pn]: i }), {});
    return Object.entries(params)
        .sort((v1, v2) => methodParamsOrder[v1[0]] - methodParamsOrder[v2[0]])
        .map(([key, val]) => val);
};
class Router {
    constructor(openrpcDocument, methodMapping) {
        this.openrpcDocument = openrpcDocument;
        if (methodMapping.mockMode) {
            this.methods = this.buildMockMethodMapping(openrpcDocument.methods);
        }
        else {
            this.methods = methodMapping;
        }
        this.methods["rpc.discover"] = this.serviceDiscoveryHandler.bind(this);
        this.methodCallValidator = new schema_utils_js_1.MethodCallValidator(openrpcDocument);
    }
    static methodNotFoundHandler(methodName) {
        return {
            error: {
                code: -32601,
                data: `The method ${methodName} does not exist / is not available.`,
                message: "Method not found",
            },
        };
    }
    async call(methodName, params) {
        const validationErrors = this.methodCallValidator.validate(methodName, params);
        if (validationErrors instanceof schema_utils_js_1.MethodNotFoundError) {
            return Router.methodNotFoundHandler(methodName);
        }
        if (validationErrors.length > 0) {
            return this.invalidParamsHandler(validationErrors);
        }
        const methodObject = this.openrpcDocument.methods.find((m) => m.name === methodName);
        const paramsAsArray = params instanceof Array ? params : sortParamKeys(methodObject, params);
        try {
            return { result: await this.methods[methodName](...paramsAsArray) };
        }
        catch (e) {
            if (e instanceof error_1.JSONRPCError) {
                return { error: { code: e.code, message: e.message, data: e.data } };
            }
            return { error: { code: 6969, message: "unknown error" } };
        }
    }
    isMethodImplemented(methodName) {
        return this.methods[methodName] !== undefined;
    }
    serviceDiscoveryHandler() {
        return Promise.resolve(this.openrpcDocument);
    }
    buildMockMethodMapping(methods) {
        const methMap = {};
        methods.forEach((method) => {
            methMap[method.name] = (...args) => {
                if (method.examples === undefined) {
                    const result = method.result;
                    return Promise.resolve(jsf.generate(result.schema));
                }
                const foundExample = method.examples.find(({ params }) => {
                    let isMatch = true;
                    params.forEach((p, i) => {
                        if (p.value !== args[i]) {
                            isMatch = false;
                        }
                    });
                    return isMatch;
                });
                if (foundExample) {
                    const foundExampleResult = foundExample.result;
                    return Promise.resolve(foundExampleResult.value);
                }
                else {
                    const result = method.result;
                    return Promise.resolve(jsf.generate(result.schema));
                }
            };
        });
        return methMap;
    }
    invalidParamsHandler(errs) {
        return {
            error: {
                code: -32602,
                data: errs,
                message: "Invalid params",
            },
        };
    }
}
exports.Router = Router;
